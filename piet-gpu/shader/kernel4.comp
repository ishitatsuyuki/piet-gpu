// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense

// This is "kernel 4" in a 4-kernel pipeline. It renders the commands
// in the per-tile command list to an image.

// Right now, this kernel stores the image in a buffer, but a better
// plan is to use a texture. This is because of limited support.

#version 450
#extension GL_GOOGLE_include_directive : enable
#ifdef ENABLE_IMAGE_INDICES
#extension GL_EXT_nonuniform_qualifier : enable
#endif
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_shuffle : enable

#include "mem.h"
#include "setup.h"

#define CHUNK 4
#define CHUNK_DX (TILE_WIDTH_PX / CHUNK)
layout(local_size_x = CHUNK_DX, local_size_y = TILE_HEIGHT_PX) in;

layout(set = 0, binding = 1) restrict readonly buffer ConfigBuf {
    Config conf;
};

layout(rgba8, set = 0, binding = 2) uniform restrict writeonly image2D image;

#ifdef ENABLE_IMAGE_INDICES
layout(rgba8, set = 0, binding = 3) uniform restrict readonly image2D images[];
#else
layout(rgba8, set = 0, binding = 3) uniform restrict readonly image2D images[1];
#endif

#include "ptcl.h"
#include "tile.h"

shared int cov[TILE_WIDTH_PX+1][TILE_HEIGHT_PX+1]; // +1 to cut down on bank conflicts, as well as to save a branch in the code

#define MAX_BLEND_STACK 128
mediump vec3 tosRGB(mediump vec3 rgb) {
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.0031308));
    mediump vec3 below = vec3(12.92)*rgb;
    mediump vec3 above = vec3(1.055)*pow(rgb, vec3(0.41666)) - vec3(0.055);
    return mix(below, above, cutoff);
}

mediump vec3 fromsRGB(mediump vec3 srgb) {
    // Formula from EXT_sRGB.
    bvec3 cutoff = greaterThanEqual(srgb, vec3(0.04045));
    mediump vec3 below = srgb/vec3(12.92);
    mediump vec3 above = pow((srgb + vec3(0.055))/vec3(1.055), vec3(2.4));
    return mix(below, above, cutoff);
}

// unpacksRGB unpacks a color in the sRGB color space to a vec4 in the linear color
// space.
mediump vec4 unpacksRGB(uint srgba) {
    mediump vec4 color = unpackUnorm4x8(srgba).wzyx;
    return vec4(fromsRGB(color.rgb), color.a);
}

// packsRGB packs a color in the linear color space into its 8-bit sRGB equivalent.
uint packsRGB(mediump vec4 rgba) {
    rgba = vec4(tosRGB(rgba.rgb), rgba.a);
    return packUnorm4x8(rgba.wzyx);
}

uvec2 chunk_offset(uint i) {
    return uvec2(i * CHUNK_DX, 0);
}

mediump vec4[CHUNK] fillImage(uvec2 xy, CmdImage cmd_img) {
    mediump vec4 rgba[CHUNK];
    for (uint i = 0; i < CHUNK; i++) {
        ivec2 uv = ivec2(xy + chunk_offset(i)) + cmd_img.offset;
        mediump vec4 fg_rgba;
#ifdef ENABLE_IMAGE_INDICES
        fg_rgba = imageLoad(images[cmd_img.index], uv);
#else
        fg_rgba = imageLoad(images[0], uv);
#endif
        fg_rgba.rgb = fromsRGB(fg_rgba.rgb);
        rgba[i] = fg_rgba;
    }
    return rgba;
}

void main() {
    uint tile_ix = gl_WorkGroupID.y * conf.width_in_tiles + gl_WorkGroupID.x;
    Alloc cmd_alloc = slice_mem(conf.ptcl_alloc, tile_ix * PTCL_INITIAL_ALLOC, PTCL_INITIAL_ALLOC);
    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);

    uvec2 xy_uint = uvec2(gl_LocalInvocationID.x + TILE_WIDTH_PX * gl_WorkGroupID.x, gl_LocalInvocationID.y + TILE_HEIGHT_PX * gl_WorkGroupID.y);
    vec2 xy = vec2(xy_uint);
    mediump vec4 rgba[CHUNK];
    uint blend_stack[MAX_BLEND_STACK][CHUNK];
    mediump float blend_alpha_stack[MAX_BLEND_STACK][CHUNK];
    for (uint i = 0; i < CHUNK; i++) {
        rgba[i] = vec4(0.0);
        // TODO: remove this debug image support when the actual image method is plumbed.
#ifdef DEBUG_IMAGES
#ifdef ENABLE_IMAGE_INDICES
        if (xy_uint.x < 1024 && xy_uint.y < 1024) {
            rgba[i] = imageLoad(images[gl_WorkGroupID.x / 64], ivec2(xy_uint + chunk_offset(i))/4);
        }
#else
        if (xy_uint.x < 1024 && xy_uint.y < 1024) {
            rgb[i] = imageLoad(images[0], ivec2(xy_uint + chunk_offset(i))/4).rgb;
        }
#endif
#endif
    }

    mediump float area[CHUNK];
    uint clip_depth = 0;
    bool mem_ok = mem_error == NO_ERROR;
    while (mem_ok) {
        uint tag = Cmd_tag(cmd_alloc, cmd_ref).tag;
        if (tag == Cmd_End) {
            break;
        }
        switch (tag) {
        case Cmd_Stroke:
            // Calculate distance field from all the line segments in this tile.
            CmdStroke stroke = Cmd_Stroke_read(cmd_alloc, cmd_ref);
            mediump float df[CHUNK];
            for (uint k = 0; k < CHUNK; k++) df[k] = 1e9;
            TileSegRef tile_seg_ref = TileSegRef(stroke.tile_ref);
            do {
                TileSeg seg = TileSeg_read(new_alloc(tile_seg_ref.offset, TileSeg_size, mem_ok), tile_seg_ref);
                vec2 line_vec = seg.vector;
                for (uint k = 0; k < CHUNK; k++) {
                    vec2 dpos = xy + vec2(0.5, 0.5) - seg.origin;
                    dpos += vec2(chunk_offset(k));
                    float t = clamp(dot(line_vec, dpos) / dot(line_vec, line_vec), 0.0, 1.0);
                    df[k] = min(df[k], length(line_vec * t - dpos));
                }
                tile_seg_ref = seg.next;
            } while (tile_seg_ref.offset != 0);
            for (uint k = 0; k < CHUNK; k++) {
                area[k] = clamp(stroke.half_width + 0.5 - df[k], 0.0, 1.0);
            }
            cmd_ref.offset += 4 + CmdStroke_size;
            break;
        case Cmd_Fill:
            CmdFill fill = Cmd_Fill_read(cmd_alloc, cmd_ref);
            uint i = gl_LocalInvocationIndex;
            uvec2 tile_xy = uvec2(TILE_WIDTH_PX * gl_WorkGroupID.x, TILE_HEIGHT_PX * gl_WorkGroupID.y);
            for (uint k = 0; k < CHUNK; k++) {
                uvec2 my_xy = uvec2(gl_LocalInvocationID.xy) + chunk_offset(k);
                cov[my_xy.x][my_xy.y] = 0;
            }
            barrier();
            if (i < TILE_HEIGHT_PX) {
                atomicAdd(cov[0][i], fill.backdrop * 65536);
            }
            tile_seg_ref = TileSegRef(fill.tile_ref);
            // Calculate coverage based on backdrop + coverage of each line segment
            do {
                TileSeg seg = TileSeg_read(new_alloc(tile_seg_ref.offset, TileSeg_size, mem_ok), tile_seg_ref);
                int yi;
                if (i < TILE_WIDTH_PX && seg.vector.x != 0) {
                    vec2 start = seg.origin - tile_xy - vec2(i, 0);
                    vec2 end = start + seg.vector;
                    vec2 window = clamp(vec2(start.x, end.x), 0., 1.);
                    vec2 t = (window - start.x) / seg.vector.x;
                    vec2 ys = vec2(mix(start.y, end.y, t.x), mix(start.y, end.y, t.y));
                    float f = seg.vector.x * seg.vector.y > 0 ? ceil(ys.x) - 1 : floor(ys.x);
                    yi = int(f);
                    if (!(start.x >= 0. && start.x < 1.) // Reject the pixel containing the start point since it's also calculated in the horizontal intersection pass
                      && yi >= 0 && yi < TILE_HEIGHT_PX) { // TODO: optimize with (yi & ~TILE_HEIGHT_PX) == 0?
                        ys -= f;
                        float y1 = clamp(ys.y, 0., 1.);
                        float t1 = (y1 - ys.x + 1e-6) / (ys.y - ys.x + 1e-6);
                        float x1 = mix(window.x, window.y, t1);
                        atomicAdd(cov[i][yi], -int((y1 - ys.x) * (1. - 0.5 * (x1 + window.x)) * 65536.));
                        atomicAdd(cov[i+1][yi], -int((y1 - ys.x) * (0.5 * (x1 + window.x)) * 65536.));
                    }
                }
                if (i < TILE_HEIGHT_PX && seg.vector.y != 0) {
                    vec2 start = seg.origin - tile_xy - vec2(0, i);
                    vec2 end = start + seg.vector;
                    vec2 window = clamp(vec2(start.y, end.y), 0., 1.);
                    vec2 t = (window - start.y) / seg.vector.y;
                    vec2 xs = vec2(mix(start.x, end.x, t.x), mix(start.x, end.x, t.y));
                    int xi = int(floor(xs.x));
                    xs -= floor(xs.x);
                    float x1 = clamp(xs.y, 0., 1.);
                    float t1 = (x1 - xs.x + 1e-6) / (xs.y - xs.x + 1e-6);
                    float y1 = mix(window.x, window.y, t1);
                    atomicAdd(cov[clamp(xi, 0, TILE_WIDTH_PX)][i], -int((y1 - window.x) * (1. - 0.5 * (x1 + xs.x)) * 65536.));
                    atomicAdd(cov[clamp(xi+1, 0, TILE_WIDTH_PX)][i], -int((y1 - window.x) * (0.5 * (x1 + xs.x)) * 65536.));
                }
                if (i < TILE_HEIGHT_PX) {
                    atomicAdd(cov[0][i], int(sign(seg.vector.x) * clamp(tile_xy.y + float(i) - seg.y_edge + 1.0, 0.0, 1.0) * 65536.));
                }
                tile_seg_ref = seg.next;
            } while (tile_seg_ref.offset != 0);
            barrier();
            int carry = 0;
            for (uint k = 0; k < CHUNK; k++) {
                uvec2 my_xy = uvec2(gl_LocalInvocationID.xy) + chunk_offset(k);
                int val = cov[my_xy.x][my_xy.y];
                int local_sum = val;
                int acc = carry + val;
                for (uint i = 1; i < CHUNK_DX; i *= 2) {
                    int shuf = subgroupShuffleXor(local_sum, i);
                    if ((gl_LocalInvocationID.x & i) != 0) {
                        acc += shuf;
                    }
                    local_sum += shuf;
                }
                area[k] = min(abs(acc / 65536.), 1.0);
                carry += local_sum;
            }
            cmd_ref.offset += 4 + CmdFill_size;
            break;
        case Cmd_Solid:
            for (uint k = 0; k < CHUNK; k++) {
                area[k] = 1.0;
            }
            cmd_ref.offset += 4;
            break;
        case Cmd_Alpha:
            CmdAlpha alpha = Cmd_Alpha_read(cmd_alloc, cmd_ref);
            for (uint k = 0; k < CHUNK; k++) {
                area[k] = alpha.alpha;
            }
            cmd_ref.offset += 4 + CmdAlpha_size;
            break;
        case Cmd_Color:
            CmdColor color = Cmd_Color_read(cmd_alloc, cmd_ref);
            mediump vec4 fg = unpacksRGB(color.rgba_color);
            for (uint k = 0; k < CHUNK; k++) {
                mediump vec4 fg_k = fg * area[k];
                rgba[k] = rgba[k] * (1.0 - fg_k.a) + fg_k;
            }
            cmd_ref.offset += 4 + CmdColor_size;
            break;
        case Cmd_Image:
            CmdImage fill_img = Cmd_Image_read(cmd_alloc, cmd_ref);
            mediump vec4 img[CHUNK] = fillImage(xy_uint, fill_img);
            for (uint k = 0; k < CHUNK; k++) {
                mediump vec4 fg_k = img[k] * area[k];
                rgba[k] = rgba[k] * (1.0 - fg_k.a) + fg_k;
            }
            cmd_ref.offset += 4 + CmdImage_size;
            break;
        case Cmd_BeginClip:
            for (uint k = 0; k < CHUNK; k++) {
                // We reject any inputs that might overflow in render_ctx.rs.
                // The following is a sanity check so we don't corrupt memory should there be malformed inputs.
                uint d = min(clip_depth, MAX_BLEND_STACK - 1);
                blend_stack[d][k] = packsRGB(vec4(rgba[k]));
                blend_alpha_stack[d][k] = clamp(abs(area[k]), 0.0, 1.0);
                rgba[k] = vec4(0.0);
            }
            clip_depth++;
            cmd_ref.offset += 4;
            break;
        case Cmd_EndClip:
            clip_depth--;
            for (uint k = 0; k < CHUNK; k++) {
                uint d = min(clip_depth, MAX_BLEND_STACK - 1);
                mediump vec4 bg = unpacksRGB(blend_stack[d][k]);
                mediump vec4 fg = rgba[k] * area[k] * blend_alpha_stack[d][k];
                rgba[k] = bg * (1.0 - fg.a) + fg;
            }
            cmd_ref.offset += 4;
            break;
        case Cmd_Jump:
            cmd_ref = CmdRef(Cmd_Jump_read(cmd_alloc, cmd_ref).new_ref);
            cmd_alloc.offset = cmd_ref.offset;
            break;
        }
    }

    for (uint i = 0; i < CHUNK; i++) {
        imageStore(image, ivec2(xy_uint + chunk_offset(i)), vec4(tosRGB(rgba[i].rgb), rgba[i].a));
    }
}
